# Set up completion
autoload -Uz compinit promptinit
zstyle ':completion:*' menu select
zmodload zsh/complist
compinit
promptinit
_comp_options+=(globdots) # Include hidden files.

# store history in cache directory:
HISTSIZE=10000
SAVEHIST=10000
HISTFILE="$HOME/.cache/zsh/history"

_has() {
  return $( whence $1 >/dev/null )
}

# ensure this is set before antidote inits
export CLOUDSDK_HOME="$HOME/.local/share/google-cloud-sdk"

if _has antibody; then
    ZSH_PLUGIN_MGR="antibody"
    ZSH_PLUGIN_LOAD_CMD="antibody bundle < $HOME/.config/zsh/antibody_plugins.txt"
    source <(antibody init)
else
    ZSH_PLUGIN_MGR="antidote"
    ZSH_PLUGIN_LOAD_CMD="antidote load $HOME/.config/zsh/antibody_plugins.txt"
    # currently only using antidote for mac
    source /opt/homebrew/opt/antidote/share/antidote/antidote.zsh
fi

# configure default added keys for ssh-agent plugin
# add key names after identities to auto add
# zstyle :omz:plugins:ssh-agent identities <add key name>
# avoid problematic behavior with zsh-poetry plugin overrides
ZSH_POETRY_OVERRIDE_SHELL=0

eval $ZSH_PLUGIN_LOAD_CMD

# shorten long hostnames with dashes (typically followed by an ID
# to everything up until the dash
short_hostname="$(hostname|sed -e 's/-.*//')"
PROMPT="[%F{1}%n%f@%F{5}${short_hostname}%f%F{3}%f]%F{6}~%f "

# Setup vi mode
bindkey -v

# Change cursor with support for inside/outside tmux
function _set_cursor() {
    if [[ $TMUX = '' ]]; then
      echo -ne $1
    else
      echo -ne "\ePtmux;\e\e$1\e\\"
    fi
}

function _set_block_cursor() { _set_cursor '\e[2 q' }
function _set_beam_cursor() { _set_cursor '\e[6 q' }

function zle-keymap-select {
  if [[ ${KEYMAP} == vicmd ]] || [[ $1 = 'block' ]]; then
      _set_block_cursor
  else
      _set_beam_cursor
  fi
}
zle -N zle-keymap-select
# ensure beam cursor when starting new terminal
precmd_functions+=(_set_beam_cursor) #
# ensure insert mode and beam cursor when exiting vim
zle-line-init() { zle -K viins; _set_beam_cursor }

# Use vim keys in tab complete menu:
bindkey -M menuselect 'h' vi-backward-char
bindkey -M menuselect 'k' vi-up-line-or-history
bindkey -M menuselect 'l' vi-forward-char
bindkey -M menuselect 'j' vi-down-line-or-history

bindkey -v '^?' backward-delete-char

bindkey '^R' history-incremental-search-backward

autoload edit-command-line; zle -N edit-command-line
bindkey '^e' edit-command-line

# Source colors generated by wal.
source "${HOME}/.cache/wal/colors.sh"

# Source aliases
source "${HOME}/.config/zsh/aliasrc"

# Source functions
source "${HOME}/.config/zsh/functionrc"

# Source completion for tmuxinator
source "${HOME}/.config/tmuxinator/tmuxinator.zsh"

# Source any machine local configuration
if [ -f "${HOME}/.profile" ]; then source "${HOME}/.profile"; fi

# Import colorscheme from 'wal'
(cat "$HOME/.cache/wal/sequences" &)

# NVM sourcing: https://aur.archlinux.org/packages/nvm
if [ -e /usr/share/nvm/init-nvm.sh ]; then
  source /usr/share/nvm/init-nvm.sh
fi

# Setup NVM following homebrew instructions
  export NVM_DIR="$HOME/.nvm"
[ -s "/opt/homebrew/opt/nvm/nvm.sh" ] && \. "/opt/homebrew/opt/nvm/nvm.sh"  # This loads nvm
[ -s "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm" ] && \. "/opt/homebrew/opt/nvm/etc/bash_completion.d/nvm"  #

if _has fzf; then
    source <(fzf --zsh)
fi

# Use ag for fzf
# Uses same command for all binds - could make this for ALT_C
# Utility function to determine whether command is executable or aliased.
if _has fzf && _has rg; then
    export FZF_DEFAULT_COMMAND='rg --files --follow --glob "!.git/*"'
    export FZF_CTRL_T_COMMAND="$FZF_DEFAULT_COMMAND"
    export FZF_ALT_C_COMMAND="cd ~/; rg --sort-files --files --null 2> /dev/null | xargs -0 dirname | uniq"

    # https://adamheins.com/blog/ctrl-p-in-the-terminal-with-fzf
    # This is the same functionality as fzf's ctrl-t, except that the file or
    # directory selected is now automatically cd'ed or opened, respectively.
    fzf-open-file-or-dir() {
      local cmd="command find -L . \
        \\( -path '*/\\.*' -o -fstype 'dev' -o -fstype 'proc' \\) -prune \
        -o -type f -print \
        -o -type d -print \
        -o -type l -print 2> /dev/null | sed 1d | cut -b3-"
      local out=$(eval $cmd | fzf-tmux --exit-0)

      if [ -f "$out" ]; then
        $EDITOR "$out" < /dev/tty
      elif [ -d "$out" ]; then
        cd "$out"
        zle reset-prompt
      fi
    }
    zle     -N   fzf-open-file-or-dir
    bindkey '^P' fzf-open-file-or-dir
fi

# The next line updates PATH for the Google Cloud SDK.
if [ -f "$HOME/.local/share/google-cloud-sdk/path.zsh.inc" ]; then . "$HOME/.local/share/google-cloud-sdk/path.zsh.inc"; fi

# The next line enables shell command completion for gcloud.
if [ -f "$HOME/.local/share/google-cloud-sdk/completion.zsh.inc" ]; then . "$HOME/.local/share/google-cloud-sdk/completion.zsh.inc"; fi

bindkey '^ ' autosuggest-accept # use ctrl+space to accept auto-suggestions

# Automatically load pyenv
if _has pyenv; then
    eval "$(pyenv init -)"
fi

# fix poetry nonsense: https://github.com/python-poetry/poetry/issues/2692
export PYTHON_KEYRING_BACKEND="keyring.backends.null.Keyring"

# Git worktree shortcuts
# Usage: gwn new-feature-name
function gwn() {
  local BRANCH_NAME="$1"
  local DIR_NAME="$(basename "$BRANCH_NAME")"
  local NEW_DIR="../$DIR_NAME"

  # 1. Check if the branch already exists locally
  if git show-ref --verify --quiet "refs/heads/$BRANCH_NAME"; then
    echo "Branch '$BRANCH_NAME' already exists. Linking to it..."
    # Add worktree pointing to existing branch (no -b flag)
    git worktree add "$NEW_DIR" "$BRANCH_NAME" || return 1
  else
    echo "Branch '$BRANCH_NAME' not found. Creating new branch..."
    # Create new branch and worktree (use -b flag)
    git worktree add -b "$BRANCH_NAME" "$NEW_DIR" || return 1
  fi

  local FILES_TO_COPY=(".secrets.env" ".env")
  echo "Copying configuration files..."
  for file in "${FILES_TO_COPY[@]}"; do
    if [ -f "$file" ]; then
      cp "$file" "$NEW_DIR/"
      echo "   └── Copied $file"
    fi
  done

  if command -v direnv &> /dev/null; then
    if [ -f "$NEW_DIR/.envrc" ] || [ -f "$NEW_DIR/.env" ]; then
      echo "Approving direnv..."
      direnv allow "$NEW_DIR"
    fi
  fi

  cd "$NEW_DIR" || return 1
  echo "Switched to $NEW_DIR"
}

function gwd() {
  if [ -z "$1" ]; then
  # No argument - Delete CURRENT worktree (if it is a worktree)

    local WORKTREE_ROOT
    WORKTREE_ROOT="$(git rev-parse --show-toplevel 2>/dev/null)"

    if [ -z "$WORKTREE_ROOT" ]; then
      echo "Error: Not inside a git repository."
      return 1
    fi

    if [ -d "$WORKTREE_ROOT/.git" ]; then
      echo "Error: This looks like a primary repository (has .git folder)."
      return 1
    fi

    # 1. Get the path to the git dir (usually points to .bare)
    local GIT_COMMON_DIR
    GIT_COMMON_DIR="$(git rev-parse --git-common-dir)"

    # 2. Resolve it to an absolute path (so it works after we cd ..)
    local ABS_GIT_DIR
    ABS_GIT_DIR="$(cd "$GIT_COMMON_DIR" && pwd)"

    local DIR_NAME="$(basename "$WORKTREE_ROOT")"
    echo "Deleting CURRENT worktree: $DIR_NAME..."

    # 3. Move out of the folder
    cd "$(dirname "$WORKTREE_ROOT")" || return 1

    # 4. Run remove using the explicit git-dir we captured earlier
    git --git-dir="$ABS_GIT_DIR" worktree remove "$WORKTREE_ROOT" --force

    # 5. Delete the folder
    rm -rf "$WORKTREE_ROOT"

    # 6. Prune using the explicit git-dir
    git --git-dir="$ABS_GIT_DIR" worktree prune

  else
    # Argument provided - Delete SIBLING worktree
    local TARGET="../$1"
    echo " Deleting sibling worktree: $1..."

    git worktree remove "$TARGET" --force
    command rm -rf "$TARGET"
    git worktree prune
  fi
}

# support direnv for local envvar loading
eval "$(direnv hook zsh)"
